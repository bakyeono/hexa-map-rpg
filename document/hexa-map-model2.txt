6각형 지도의 좌표 처리 방법


아래는 제가 처음 6각형 지도를 구현할 때 쓴 좌표 방식입니다. 홀수행을 오른쪽으로 한칸씩 밀어서 짝수행과 똑같이 x값을 주었습니다.
이 방식의 장점은 고전적인 4각형 지도처럼 2차원 배열과 좌표가 1:1 대응한다는 점입니다. 하지만 y축 값에 따라 실제 x축 위치가 변하므로 x 좌표만으로는 위치를 정확하게 파악하기가 어렵다는 단점이 있습니다. 가령 (2,2)과 (2,3) 중 어느 것이 더 왼쪽에 있는 위치인지를 알려면 y축이 짝수인지 홀수인지 한 번씩 더 생각해야 한다는 것이죠. 또 이동방향에 따른 좌표값의 변화도 직관적이지 못합니다. 이 방법을 지도 출력이나 시야처리/길찾기 알고리즘에 적용하면 매우 혼란스럽습니다.


y   x
0   0 1 2 3 4 5 6 7 8 9 
1    0 1 2 3 4 5 6 7 8 9
2   0 1 2 3 4 5 6 7 8 9 
3    0 1 2 3 4 5 6 7 8 9
4   0 1 2 3 4 5 6 7 8 9 
5    0 1 2 3 4 5 6 7 8 9
6   0 1 2 3 4 5 6 7 8 9 
7    0 1 2 3 4 5 6 7 8 9
8   0 1 2 3 4 5 6 7 8 9 
9    0 1 2 3 4 5 6 7 8 9

* 이동방향에 따른 좌표 수정
direction_east      = x--;
direction_west      = x++;
direction_northeast = (y%2 == 0) ? x-- : ; y--;
direction_northwest = (y%2 == 1) ? x++ : ; y--;
direction_southeast = (y%2 == 0) ? x-- : ; y++;
direction_southwest = (y%2 == 1) ? x++ : ; y++;

* 1차원 배열 참조 인덱스 : idx = (y*columns) + x;




그래서 고민하다 새로운 방법을 생각했습니다. 짝수행에는 짝수값을 홀수행에는 홀수값을 주는 것입니다. 이렇게 하면 x축 좌표만 보고도 어느 좌표가 더 왼쪽인지 오른쪽인지 바로 알 수 있고, 홀수행인지 짝수행인지도 알 수 있습니다. 게다가 여섯 가지 이동방향에 따른 좌표의 변화량이 모두 (벡터)2 씩이므로 매우 직관적입니다.
한 가지 문제는 이렇게 할 경우 각 행마다 비는 열들이 n/2 개씩 생긴다는 것입니다. 하지만 이 낭비는 비는 열을 고려하지 않고 모두 연속해서 배열에 집어넣은 뒤 좌표값에 따라 참조하는 공식을 만들면 간단히 해결됩니다. (게다가 연산 내용도 /2와 %2 이므로 가볍네요)


새로운 방식

y   x         10        20
0   0 2 4 6 8 0 2 4 6 8 
1    1 3 5 7 9 1 3 5 7 9
2   0 2 4 6 8 0 2 4 6 8 
3    1 3 5 7 9 1 3 5 7 9
4   0 2 4 6 8 0 2 4 6 8 
5    1 3 5 7 9 1 3 5 7 9
6   0 2 4 6 8 0 2 4 6 8 
7    1 3 5 7 9 1 3 5 7 9
8   0 2 4 6 8 0 2 4 6 8 
9    1 3 5 7 9 1 3 5 7 9

* 이동방향에 따른 좌표 수정
direction_east      = x--; x--;
direction_west      = x++; x++;
direction_northeast = y--; x--;
direction_northwest = y--; x++;
direction_southeast = y++; x--;
direction_southwest = y++; x++;

* 1차원 배열 참조 인덱스: idx = (y*columns) + ((x/2)+(x%2));


이미 개발된 많은 6각형 맵 게임들은 어떻게 처리하는지 궁금하네요 ㅎ
